import utils from './utils';
let {db, yesterday, today, tommorow,Audio, PushNotification, moment} = utils;
import functions from './main/functions';
let {getDays, getReminders, getDayDate} = functions;

import BackgroundTimer from 'react-native-background-timer';


export const API  = {
  fetchDay : (date) => {
    return  new Promise((resolve, reject) => {
       db.findOne({ _id: date }, function (err, doc) {
         resolve(doc)
      });
    });
  },
  addReminder : (payload) => {
    let {about,date, time, recordings} = payload;
    let i = 0;
    let month=0;
    let year=0;
    if(parseInt(date.substring(3,5) == NaN)){
      month = parseInt(date.substring(2,4));
    }
    if(parseInt(date.substring(6) == NaN)){
      year=parseInt(date.substring(5));
    }
    let num=parseInt(date.substring(0,2)) + "" + month + "" + year +""+Math.floor((Math.random() * 10000) + 1)
    db.findOne({ _id: date }, function (err, doc) {
       if(doc==null){
         let Doc = {
               _id : date,
               reminders:[
                {
                  about:about,
                  time:time,
                  recordings:recordings,
                  date:date,
                  completed:false
                }
              ],
              events:[]
             };
          db.insert(Doc, function (err, newDoc) {   // Callback i11s optional
          });
       }
       else{
         db.update({ _id: date }, { $push: { reminders: payload } }, {}, function (err, numAffected, affectedDocuments, upsert) {

         });
       }
    });
    if(date == getDayDate(today)){
      let diff = 950000;
      let ongoing = true;
      if(time != false){
        let now = new Date();
        let then = new Date();
        then.setHours(parseInt(time.substring(0,2)))
        then.setMinutes(parseInt(time.substring(3,5)))
        then.setSeconds(0)
        diff=then-now;
        ongoing=false;
      }

      PushNotification.localNotificationSchedule({
        title: "Opomnik", // (optional, for iOS this is only used in apple watch, the title will be the app name on other iOS devices)
        message: about, // (required)
        date: new Date(Date.now() + (diff)), // in 60 secs
        id: num, // (optional) Valid unique 32 bit integer specified as string. default: Autogenerated Unique ID
      //  ticker: "My Notification Ticker", // (optional)
      //  largeIcon: "ic_launcher", // (optional) default: "ic_launcher"
      //  smallIcon: "ic_notification", // (optional) default: "ic_notification" with fallback for "ic_launcher"
      //  bigText: "My big text that will be shown when notification is expanded", // (optional) default: "message" prop
        subText: "This is a subText", // (optional) default: none
        color: "red", // (optional) default: system default
        vibrate: true, // (optional) default: true
        vibration: 300, // vibration length in milliseconds, ignored if vibrate=false, default: 1000
      //  tag: 'some_tag', // (optional) add tag to message
      //  group: "group", // (optional) add group to message
        ongoing: ongoing, // (optional) set whether this is an "ongoing" notification
        /* iOS and Android properties */
      });
    }

  },
  addEvent : (payload) => {
    let {about,date, from,to, recordings, alarm} = payload;
    let i = 0;
    let month=0;
    let year=0;
    if(parseInt(date.substring(3,5) == NaN)){
      month = parseInt(date.substring(2,4));
    }
    if(parseInt(date.substring(6) == NaN)){
      year=parseInt(date.substring(5));
    }
    let num=parseInt(date.substring(0,2)) + "" + month + "" + year +""+Math.floor((Math.random() * 10000) + 1)
    payload.id = num;
    db.findOne({ _id: date }, function (err, doc) {
       if(doc==null){
         let Doc = {
               _id : date,
               events:[
                {
                  about:about,
                  from:from,
                  to:to,
                  recordings:recordings,
                  date:date,
                  alarm:alarm,
                  id:num
                }
              ],
              reminders:[]
             };
          db.insert(Doc, function (err, newDoc) {   // Callback i11s optional
          });
       }
       else{
         db.update({ _id: date }, { $push: { events: payload } }, {}, function (err, numAffected, affectedDocuments, upsert) {

         });
       }
    });
    if(date == getDayDate(today)){
      let diff = 950000;
      if(from != false){
        let now = new Date();
        let then = new Date();
        then.setHours(parseInt(from.substring(0,2)))
        then.setMinutes(parseInt(from.substring(3,5)) - parseInt(alarm))
        then.setSeconds(0)
        diff=then-now;
      }
      PushNotification.localNotificationSchedule({
        title: "Dogodek", // (optional, for iOS this is only used in apple watch, the title will be the app name on other iOS devices)
        message: about, // (required)
        date: new Date(Date.now() + (diff)), // in 60 secs
        id: num, // (optional) Valid unique 32 bit integer specified as string. default: Autogenerated Unique ID
      //  ticker: "My Notification Ticker", // (optional)
      //  largeIcon: "ic_launcher", // (optional) default: "ic_launcher"
      //  smallIcon: "ic_notification", // (optional) default: "ic_notification" with fallback for "ic_launcher"
      //  bigText: "My big text that will be shown when notification is expanded", // (optional) default: "message" prop
        subText: "This is a subText", // (optional) default: none
        color: "red", // (optional) default: system default
        vibrate: true, // (optional) default: true
        vibration: 300, // vibration length in milliseconds, ignored if vibrate=false, default: 1000
      //  tag: 'some_tag', // (optional) add tag to message
      //  group: "group", // (optional) add group to message
        ongoing: true, // (optional) set whether this is an "ongoing" notification
        /* iOS and Android properties */
      });
    }

  },

  completeReminder: (payload) => {
    let{date,i} = payload;
    db.findOne({ _id: date }, function (err, doc) {
      let reminders  = doc.reminders;
      reminders[i].completed = true;
      db.update({ _id : date }, { $set: { reminders: reminders } }, {}, function (err, numReplaced) {
      });
    });
  },

  editReminder : (payload) => {
    let {about,date, time, recordings,i, id} = payload;
    db.findOne({ _id: date }, function (err, doc) {
      let reminders  = doc.reminders;
      let rem= doc.reminders[i];
      reminders[i] = {about,time,date,recordings, id}
      db.update({ _id : date }, { $set: { reminders: reminders } }, {}, function (err, numReplaced) {
      });
      if(rem.time != time || rem.about != about || rem.recordings.length != recordings.length){
        PushNotification.cancelLocalNotifications({id: id});
        if(date == getDayDate(today)){
          let diff = 950000;
          let ongoing = true;
          if(time != false){
            let now = new Date();
            let then = new Date();
            then.setHours(parseInt(time.substring(0,2)))
            then.setMinutes(parseInt(time.substring(3,5)))
            then.setSeconds(0)
            diff=then-now;
          }

          PushNotification.localNotificationSchedule({
            title: "Opomnik", // (optional, for iOS this is only used in apple watch, the title will be the app name on other iOS devices)
            message: about, // (required)
            date: new Date(Date.now() + (diff)), // in 60 secs
            id: id, // (optional) Valid unique 32 bit integer specified as string. default: Autogenerated Unique ID
          //  ticker: "My Notification Ticker", // (optional)
          //  largeIcon: "ic_launcher", // (optional) default: "ic_launcher"
          //  smallIcon: "ic_notification", // (optional) default: "ic_notification" with fallback for "ic_launcher"
          //  bigText: "My big text that will be shown when notification is expanded", // (optional) default: "message" prop
            subText: "This is a subText", // (optional) default: none
            color: "red", // (optional) default: system default
            vibrate: true, // (optional) default: true
            vibration: 300, // vibration length in milliseconds, ignored if vibrate=false, default: 1000
          //  tag: 'some_tag', // (optional) add tag to message
          //  group: "group", // (optional) add group to message
            ongoing: true, // (optional) set whether this is an "ongoing" notification
            /* iOS and Android properties */
          });
        }
      }
    });
  },
  editEvent : (payload) => {
    let {about,date, from,to,alarm, recordings,i, id} = payload;
    db.findOne({ _id: date }, function (err, doc) {
      let reminders  = doc.events;
      let rem= doc.events[i];
      reminders[i] = {about,date,recordings, id, from,to, alarm}
      db.update({ _id : date }, { $set: { events: reminders } }, {}, function (err, numReplaced) {
      });
      if(rem.from != from || rem.about != about || rem.recordings.length != recordings.length || rem.alarm != alarm){
        PushNotification.cancelLocalNotifications({id: id});
        if(date == getDayDate(today)){
          let diff = 950000;
          if(from != false){
            let now = new Date();
            let then = new Date();
            then.setHours(parseInt(from.substring(0,2)))
            then.setMinutes(parseInt(from.substring(3,5)) - parseInt(alarm))
            then.setSeconds(0)
            diff=then-now;
          }
          PushNotification.localNotificationSchedule({
            title: "Dogodek", // (optional, for iOS this is only used in apple watch, the title will be the app name on other iOS devices)
            message: about, // (required)
            date: new Date(Date.now() + (diff)), // in 60 secs
            id: id, // (optional) Valid unique 32 bit integer specified as string. default: Autogenerated Unique ID
          //  ticker: "My Notification Ticker", // (optional)
          //  largeIcon: "ic_launcher", // (optional) default: "ic_launcher"
          //  smallIcon: "ic_notification", // (optional) default: "ic_notification" with fallback for "ic_launcher"
          //  bigText: "My big text that will be shown when notification is expanded", // (optional) default: "message" prop
            subText: "This is a subText", // (optional) default: none
            color: "red", // (optional) default: system default
            vibrate: true, // (optional) default: true
            vibration: 300, // vibration length in milliseconds, ignored if vibrate=false, default: 1000
          //  tag: 'some_tag', // (optional) add tag to message
          //  group: "group", // (optional) add group to message
            ongoing: true, // (optional) set whether this is an "ongoing" notification
            /* iOS and Android properties */
          });
        }
      }
    });
  },

  deleteReminder : (payload) => {
    let {i,date} = payload;
    db.findOne({ _id: date }, function (err, doc) {
      let reminders  = doc.reminders;
      PushNotification.cancelLocalNotifications({id: reminders[i].id});
      for(let d = 0; d< reminders[i].recordings.length; d++){
       Audio.deleteRec(date, reminders[i].recordings[d].num);
     }
      reminders.splice(i,1);
      db.update({ _id : date }, { $set: { reminders: reminders } }, {}, function (err, numReplaced) {
      });
    });

  },
  deleteEvent : (payload) => {
    let {i,date} = payload;
    db.findOne({ _id: date }, function (err, doc) {
      let reminders  = doc.events;
      PushNotification.cancelLocalNotifications({id: reminders[i].id});
      for(let d = 0; d< reminders[i].recordings.length; d++){
       Audio.deleteRec(date, reminders[i].recordings[d].num);
     }
      reminders.splice(i,1);
      db.update({ _id : date }, { $set: { events: reminders } }, {}, function (err, numReplaced) {
      });
    });

  },

 initializeDays : (store) => {
   let days = {};
   let reminders = {};
   let events = {};
   db.find({ _id: getDayDate(yesterday)}, function (err, docs) {
     if(docs.length > 0){days[0] = getDays(docs, 0); reminders[0] = {id:0, reminders:docs[0].reminders};events[0] = {id:0, events:docs[0].events};}

     db.find({ _id: getDayDate(today)}, function (err, docs) {
        if(docs.length > 0){
          days[1] = getDays(docs, 1);reminders[1] = {id:1, reminders:docs[0].reminders};
          events[1] = {id:1, events:docs[0].events};
        let r = docs[0].reminders;
        for(let j = 0; j<r.length; j++){
          if(r[j].completed == false){
            let diff = 950000;
            let ongoing = true;
            if(r[j].time != false){
              let now = new Date();
              let then = new Date();
              then.setHours(parseInt(r[j].time.substring(0,2)))
              then.setMinutes(parseInt(r[j].time.substring(3,5)))
              then.setSeconds(0)
              diff=then-now;
              ongoing=false;
            }
            PushNotification.localNotificationSchedule({
              title: "Opomnik", // (optional, for iOS this is only used in apple watch, the title will be the app name on other iOS devices)
              message: r[j].about, // (required)
              date: new Date(Date.now() + (diff)), // in 60 secs
              id: r[j].id, // (optional) Valid unique 32 bit integer specified as string. default: Autogenerated Unique ID
            //  ticker: "My Notification Ticker", // (optional)
            //  largeIcon: "ic_launcher", // (optional) default: "ic_launcher"
            //  smallIcon: "ic_notification", // (optional) default: "ic_notification" with fallback for "ic_launcher"
            //  bigText: "My big text that will be shown when notification is expanded", // (optional) default: "message" prop
              subText: "This is a subText", // (optional) default: none
              color: "red", // (optional) default: system default
              vibrate: true, // (optional) default: true
              vibration: 300, // vibration length in milliseconds, ignored if vibrate=false, default: 1000
            //  tag: 'some_tag', // (optional) add tag to message
            //  group: "group", // (optional) add group to message
              ongoing: ongoing, // (optional) set whether this is an "ongoing" notification
              /* iOS and Android properties */
            });
          }
        }

        db.find({ _id: getDayDate(tommorow)}, function (err, docs) {
           if(docs.length > 0){days[2] = getDays(docs, 2);reminders[2] = {id:2, reminders:docs[0].reminders};events[2] = {id:2, events:docs[0].events};}
           store.dispatch({type:"INITIALIZEDAYS", payload:days});
           store.dispatch({type:"INITIALIZEREMINDERS",payload:reminders})
           store.dispatch({type:"INITIALIZEEVENTS",payload:events})

         });
       }
      });
   });
 },

}
